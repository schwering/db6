* Gen_BTrees
      * Reorganize implementieren:
        Ein Task, der immer wieder ueber den B-Baum laeuft,
        unterlaufene Blaetter merget, hintere Bloecke in vordere
        freigewordene Bloecke kopiert und dabei heftig lockt.
        Das ganze koennte Deadlocks verhindern, indem es anfangs
        alle fuer eine Verschiebeoperation notwendigen Bloecke
        lockt, dies nach einem Timeout aber abbricht, bei Erfolg
        aber nochmal auf Konsistenz prueft; im Nicht-Erfolgsfall
        wuerde das ganze einfach neustarten.
      * Overflow-Pages:
        Wenn ein Wert (oder auch der Schluessel?) zu grosz ist,
        soll er in weitere Seiten ueberlaufen. Das wuerde aber
        viele Aenderungen in den formalen generischen Parametern
        nach sich ziehen (man braeuchte Iteratoren-aehnliche
        Dinger zum Serialisieren). Auszerdem wuerde es das Problem,
        dass grosze Datenmengen bei mehreren Eintraegen in B-Baeumen
        nicht mehrfach gespeichert werden, nicht beheben.

* Distributed_IO:
        assemble/disassemble baut Adressen
        oip = own IP address
        ctr = counter that increments with each network operation
        Write (in addr, in block): Alle muessen bestaetigen
                S := disassemble(addr)
            (*) for all (ip, addr) in S:
                -> Send ip (oip, ctr,  addr, block)
                for all:
                <- Recv (ip, ctr, addr)
                S := S \ {(ip, addr)}
                delay
                if |S| > 0 then go to (*)
        Write_New (out addr, in block):
                addr := assemble(S)
        Read (in addr, out block): Einer muss antworten
                S := disassemble(addr)
                for all (ip, addr) in S:
                -> Send ip (oip, ctr, addr, block)
                <- Recv (ip, ctr, block)


