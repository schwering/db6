* Shadowing:
  Einfaches Shadowing aus Folien nicht uebertragbar, da offensives Splitten
  nicht moeglich ist und wir einen Blink-Tree haben.
  1. Fuer alle Versionen des Trees gibt es eine gemeinsame Refcount-Map:
     Phys-Addr -> Refcount
     Die Refcount eines Knotens zeigt an, wie viele andere KNOTEN auf diesen
     Knoten zeigen.
     Fuer Knoten N sei L logische und P physische Adreses.
     Clone:
       kopiere Wurzel N mit L an neue P und setze Refcount(P) := Degree(N)
     Relocate:
       schreibe N mit L an neue P und setze Refcount(P) := Pointer_Count(N)
       wobei Pointer_Count(N) := |Pointers(N)|
       wobei Pointers(N) := Children(N) \cup { Left(N), Right(N), Parent(N) falls Valid }
     Write:
       if Refcount(P) = Pointer_Count(N):
         Simply_Write
         P \in (Pointers(N') \ Pointers(N)): Dec_Refcount(P);
         P \in (Pointers(N) \ Pointers(N')): Inc_Refcount(P);
       else
         ach alles Kacke verdammte
     Dec_Refcount:
       Refcount(N) := Refcount(N) - 1
       if Refcount(N) = 0 then Free_Node(N)
     Inc_Refcount:
       Refcount(N) := Refcount(N) + 1
  2. Fuer jede Version des Trees gibt es eine Map
     Virt-Addr -> Phys-Addr
     Koennte man so realisieren: insgesamt nur eine Map
     (Tree-Version-ID, Virt-Addr) -> Phys-Addr
     wenn dann (ID, Addr) gelookupt werden soll und nicht in der Map enthalten
     ist, wird bei Vorgaengern geschaut, bis gefunden, und dann 
     (ID, Addr) -> Phys-Addr eingefuegt
  3. Vorgaenger-Map: 
     (Tree-Version-ID) -> (Tree-Version-ID)
     wenn geshadowed wird, ist die neue Tree-Version-ID der maximale Key in
     der Map + 1
  
* Storage_Pools fuer Caches

* Die Heap-Geschichte mit 32 Bit TESTEN TESTEN TEST

ERLEDIGT:
* Transaktionen: Gen_Buffers: mit einer Write-Liste und einem kleinen Cache
  <- die Idee war ja, dass Read nicht den Buffer zumuellt. Das war auch nie
  der Fall auszer fuer die Read-Prozedur, die ein Item_Constant_Access_Type
  setzt (die muss das auch machen).
* Gen_Heaps:   auch auf OO umstellen (?) <- wenn auch unschoen gemacht 
  (if Read-Transaction then bla else blupp in Gen_Heaps.Get)
* Auf 32-Bit-Systemen gibt es ne Exception im Heap, wenn die Chunks >4GB werden,
  weil IO.Blocks.Size_Type verwendet wird.
* Is_Context_Free_Serialization
  Wahrscheinlich mit Degree >= 2 bestmoeglich gefixt
* Unset_Free_Following koennte die Transaktion unkontrolliert aufblasen!!
  Doch nicht zu Gebieten zusammenfassen?
  STIMMT DOCH NICHT, GLAUB ICH
* Gen_Heaps Cursor => Problem irgendwie beheben, eine Moeglichkeit waere
  in Gen_BTrees Transaktions-Cursor zu bauen


Alt, aber vielleicht noch interessant und auf jeden Fall noch nicht erledigt:

* Table_Tree
	* Siehe Timed_Table_Tree und streiche die Times.
* Timed_Table_Tree
	* Gen_BTree mit zwei Dimensionen Row, Column, Time
	* Iterator bekommt einen Selektor uebergeben, der anhand von Columns und
	  Times rausfiltern kann
	* Vorgefertigte Selektoren fuer Times (Time <= Now, aktuellsten 3
	  Eintraege usw.) und Columns (beginnt-mit)
* Bitmap
	* Verkettete Liste von Bloecken
	* Komprimierung: statt (0, ..., 0) oder (1, ..., 1) (n, 0) bzw. (n, 1)
	* Oder diese baumartige Bitmap
	* Iterator: von n-tem Eintrag bis m-ten Eintrag
	* Reorganize Prozedure
* Cache(s)
	* Eine besondere Realisierung von Gen_IO; der Cache bekommt ein anderes
	  Gen_IO uebergeben, das er cacht, ist aber gleichzeitig selbst ein
	  Gen_IO.

