separate (DB.Gen_BTrees)
package body Updating is

   procedure Update
     (Tree      : in out Tree_Type;
      Key       : in     Key_Type;
      Value     : in     Value_Type;
      Old_Value :    out Value_Type;
      Position  :    out Count_Type;
      State     :    out Result_Type)
   is
      pragma Assert (Tree.Initialized);
      Transaction : RW_Transaction_Type := New_RW_Transaction(Tree);
   begin
      Start_Transaction(Tree, Transaction);
      Update(Tree, Transaction, Key, Value, Old_Value, Position, State);
      if State = Success then
         Commit_Transaction(Tree, Transaction);
      else
         Abort_Transaction(Tree, Transaction);
      end if;
   exception
      when others =>
         Abort_Transaction(Tree, Transaction);
         raise;
   end Update;


   procedure Update
     (Tree        : in out Tree_Type;
      Transaction : in out RW_Transaction_Type'Class;
      Key         : in     Key_Type;
      Value       : in     Value_Type;
      Old_Value   :    out Value_Type;
      Position    :    out Count_Type;
      State       :    out Result_Type)
   is
      pragma Assert (Tree.Initialized);
      pragma Assert (Transaction.Initialized);
      pragma Assert (Transaction.Owning_Tree = Tree.Self);
      pragma Assert (Transaction.Started);

      N_A : Nodes.Valid_Address_Type;
      I   : Nodes.Index_Type;
   begin
      N_A      := Transaction.Current_Root_Address;
      Position := 0;
      loop
         declare
            use type Nodes.Degree_Type;
            N : constant Nodes.Node_Type := Read_Node(Tree, Transaction, N_A);
         begin
            I := Nodes.Key_Position(N, Key);
            if not Nodes.Is_Valid(I) or else
               (Nodes.Is_Leaf(N) and then (Nodes.Key(N, I) /= Key)) then
               State := Failure;
               return;
            end if;
            if Nodes.Is_Leaf(N) then
               Position := Position + Nodes.Count_Sum(N, I);
               exit;
            end if;
            Position := Position + Nodes.Count_Sum(N, I-1);
            N_A      := Nodes.Child(N, I);
         end;
      end loop;

      declare
         N : Nodes.Node_Type := Read_Node(Tree, Transaction, N_A);
      begin
         Old_Value := Nodes.Value(N, I);
         Nodes.Set_Value(N, I, Value);
         Write_Node(Tree, Transaction, N_A, N);
         State := Success;
      end;

   exception
      when others =>
         pragma Warnings (Off);
         State := Error;
         pragma Warnings (On);
         raise;
   end Update;


   procedure Update
     (Tree      : in out Tree_Type;
      Position  : in     Count_Type;
      Value     : in     Value_Type;
      Old_Value :    out Value_Type;
      Key       :    out Key_Type;
      State     :    out Result_Type)
   is
      pragma Assert (Tree.Initialized);
      Transaction : RW_Transaction_Type := New_RW_Transaction(Tree);
   begin
      Start_Transaction(Tree, Transaction);
      Update(Tree, Transaction, Position, Value, Old_Value, Key, State);
      if State = Success then
         Commit_Transaction(Tree, Transaction);
      else
         Abort_Transaction(Tree, Transaction);
      end if;
   exception
      when others =>
         Abort_Transaction(Tree, Transaction);
         raise;
   end Update;


   procedure Update
     (Tree        : in out Tree_Type;
      Transaction : in out RW_Transaction_Type'Class;
      Position    : in     Count_Type;
      Value       : in     Value_Type;
      Old_Value   :    out Value_Type;
      Key         :    out Key_Type;
      State       :    out Result_Type)
   is
      pragma Assert (Tree.Initialized);
      pragma Assert (Transaction.Initialized);
      pragma Assert (Transaction.Owning_Tree = Tree.Self);
      pragma Assert (Transaction.Started);

      N_A : Nodes.Valid_Address_Type;
      I   : Nodes.Index_Type;
      Pos : Count_Type;
   begin
      N_A := Transaction.Current_Root_Address;
      Pos := Position;
      loop
         declare
            use type Nodes.Degree_Type;
            N : constant Nodes.Node_Type := Read_Node(Tree, Transaction, N_A);
         begin
            I := Nodes.Count_Position(N, Pos);
            if not Nodes.Is_Valid(I) then
               State := Failure;
               return;
            end if;
            exit when Nodes.Is_Leaf(N);
            Pos := Pos - Nodes.Count_Sum(N, I-1);
            N_A := Nodes.Child(N, I);
         end;
      end loop;

      declare
         N : Nodes.Node_Type := Read_Node(Tree, Transaction, N_A);
      begin
         Key       := Nodes.Key(N, I);
         Old_Value := Nodes.Value(N, I);
         Nodes.Set_Value(N, I, Value);
         Write_Node(Tree, Transaction, N_A, N);
         State := Success;
      end;

   exception
      when others =>
         pragma Warnings (Off);
         State := Error;
         pragma Warnings (On);
         raise;
   end Update;

end Updating;

